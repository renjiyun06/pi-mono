#!/usr/bin/env node
// @generated by pi-monorepo@0.0.3 on 2026-02-16T16:50:24.178Z. DO NOT EDIT.
import { Command } from 'commander';
import { createRuntime, createServerProxy } from 'mcporter';
import { createCallResult } from 'mcporter';

const embeddedServer = {
  "name": "understand",
  "description": "Understand is an anti-cognitive-debt tool. Use understand_quiz to generate comprehension questions for code, understand_evaluate to check answers, and understand_score to track comprehension across files.",
  "command": {
    "kind": "stdio",
    "command": "npx",
    "args": [
      "tsx",
      "/home/lamarck/pi-mono/lamarck/projects/understand/mcp-server.ts"
    ],
    "cwd": "/home/lamarck/pi-mono/config"
  },
  "source": {
    "kind": "local",
    "path": "/home/lamarck/pi-mono/config/mcporter.json"
  },
  "sources": [
    {
      "kind": "local",
      "path": "/home/lamarck/pi-mono/config/mcporter.json"
    }
  ]
} as const;
const embeddedSchemas = {
  "understand_quiz": {
    "type": "object",
    "properties": {
      "code": {
        "type": "string",
        "description": "The code to generate questions for"
      },
      "filename": {
        "type": "string",
        "description": "Filename for context (e.g., 'rate-limiter.ts')"
      },
      "count": {
        "default": 3,
        "description": "Number of questions (default: 3)",
        "type": "number"
      }
    },
    "required": [
      "code",
      "filename"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "understand_evaluate": {
    "type": "object",
    "properties": {
      "question": {
        "type": "string",
        "description": "The comprehension question"
      },
      "key_concepts": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Key concepts the answer should cover"
      },
      "answer": {
        "type": "string",
        "description": "The developer's answer"
      },
      "code": {
        "type": "string",
        "description": "The relevant code"
      },
      "filename": {
        "description": "Filename for score tracking",
        "type": "string"
      }
    },
    "required": [
      "question",
      "key_concepts",
      "answer",
      "code"
    ],
    "$schema": "http://json-schema.org/draft-07/schema#"
  },
  "understand_score": {
    "type": "object",
    "properties": {
      "directory": {
        "description": "Project directory to check (default: current directory)",
        "type": "string"
      },
      "threshold": {
        "default": 6,
        "description": "Score threshold for 'at risk' files (default: 6)",
        "type": "number"
      }
    },
    "$schema": "http://json-schema.org/draft-07/schema#"
  }
} as const;
const embeddedName = "understand";
const embeddedDescription = "Understand is an anti-cognitive-debt tool. Use understand_quiz to generate comprehension questions for code, understand_evaluate to check answers, and understand_score to track comprehension across files.";
const generatorInfo = "Generated by pi-monorepo@0.0.3 â€” https://github.com/steipete/mcporter";
const generatorTools = [
  {
    "name": "understand-quiz",
    "description": "Generate comprehension questions for a code file. Tests design decisions, failure modes, and architectural understanding â€” not just syntax. Requires OPENROUTER_API_KEY.",
    "usage": "understand-quiz --code <code> --filename <filename> [--count <count:number>] [--raw <json>]",
    "flags": "--code <code> --filename <filename> [--count <count:number>] [--raw <json>]"
  },
  {
    "name": "understand-evaluate",
    "description": "Evaluate a developer's answer to a comprehension question. Returns score (0-10), feedback, and missed concepts. Requires OPENROUTER_API_KEY.",
    "usage": "understand-evaluate --question <question> --key-concepts <key-concepts:value1,value2> --answer <answer> --code <code> [--filename <filename>] [--raw <json>]",
    "flags": "--question <question> --key-concepts <key-concepts:value1,value2> --answer <answer> --code <code> [--filename <filename>] [--raw <json>]"
  },
  {
    "name": "understand-score",
    "description": "Get comprehension score history for tracked files. Shows per-file scores, trends, and files below a configurable threshold.",
    "usage": "understand-score [--directory <directory>] [--threshold <threshold:number>] [--raw <json>]",
    "flags": "[--directory <directory>] [--threshold <threshold:number>] [--raw <json>]"
  }
] as const;
const embeddedMetadata = {
  "schemaVersion": 1,
  "generatedAt": "2026-02-16T16:50:24.178Z",
  "generator": {
    "name": "pi-monorepo",
    "version": "0.0.3"
  },
  "server": {
    "name": "understand",
    "source": {
      "kind": "local",
      "path": "/home/lamarck/pi-mono/config/mcporter.json"
    },
    "definition": {
      "name": "understand",
      "description": "Understand is an anti-cognitive-debt tool. Use understand_quiz to generate comprehension questions for code, understand_evaluate to check answers, and understand_score to track comprehension across files.",
      "command": {
        "kind": "stdio",
        "command": "npx",
        "args": [
          "tsx",
          "/home/lamarck/pi-mono/lamarck/projects/understand/mcp-server.ts"
        ],
        "cwd": "/home/lamarck/pi-mono/config"
      }
    }
  },
  "artifact": {
    "path": "",
    "kind": "template"
  },
  "invocation": {
    "serverRef": "understand",
    "configPath": "/home/lamarck/pi-mono/config/mcporter.json",
    "runtime": "node",
    "bundler": "rolldown",
    "timeoutMs": 30000,
    "minify": false
  }
} as const;
const artifactKind = determineArtifactKind();
const program = new Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), 30000);
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = {
  "understand-quiz": "function understand_quiz(code: string, filename: string, count?: number);",
  "understand-evaluate": "function understand_evaluate(question: string, key_concepts: string[], answer: string, code: string, filename?: string);",
  "understand-score": "function understand_score(directory?: string, threshold?: number);"
};
program.configureHelp({
	commandTerm(cmd) {
		const term = cmd.name();
		return commandSignatures[term] ?? cmd.name();
	},
});
program.showSuggestionAfterError(true);

program
	.command("understand-quiz")
	.summary("understand-quiz --code <code> --filename <filename> [--count <count:number>] [--raw <json>]")
	.description("Generate comprehension questions for a code file. Tests design decisions, failure modes, and architectural understanding â€” not just syntax. Requires OPENROUTER_API_KEY.")
	.usage("--code <code> --filename <filename> [--count <count:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--code <code>", "The code to generate questions for")
	.requiredOption("--filename <filename>", "Filename for context (e.g., 'rate-limiter.ts')")
	.option("--count <count:number>", "Number of questions (default: 3) (default: 3; example: 3)", (value) => parseFloat(value))
	
	.alias("understand_quiz")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.code !== undefined) args.code = cmdOpts.code;
		if (cmdOpts.filename !== undefined) args.filename = cmdOpts.filename;
		if (cmdOpts.count !== undefined) args.count = cmdOpts.count;
			const call = (proxy.understandQuiz as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call understand.understand_quiz(code: \"value\", filename: \"value\", ...)");

program
	.command("understand-evaluate")
	.summary("understand-evaluate --question <question> --key-concepts <key-concepts:value1,value2> --answer <answer> --code <code> [--filename <filename>] [--raw <json>]")
	.description("Evaluate a developer's answer to a comprehension question. Returns score (0-10), feedback, and missed concepts. Requires OPENROUTER_API_KEY.")
	.usage("--question <question> --key-concepts <key-concepts:value1,value2> --answer <answer> --code <code> [--filename <filename>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--question <question>", "The comprehension question")
	.requiredOption("--key-concepts <key-concepts:value1,value2>", "Key concepts the answer should cover (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.requiredOption("--answer <answer>", "The developer's answer")
	.requiredOption("--code <code>", "The relevant code")
	.option("--filename <filename>", "Filename for score tracking")
	
	.alias("understand_evaluate")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.question !== undefined) args.question = cmdOpts.question;
		if (cmdOpts.keyConcepts !== undefined) args.key_concepts = cmdOpts.keyConcepts;
		if (cmdOpts.answer !== undefined) args.answer = cmdOpts.answer;
		if (cmdOpts.code !== undefined) args.code = cmdOpts.code;
		if (cmdOpts.filename !== undefined) args.filename = cmdOpts.filename;
			const call = (proxy.understandEvaluate as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call understand.understand_evaluate(question: \"value\", key_concep, ...)");

program
	.command("understand-score")
	.summary("understand-score [--directory <directory>] [--threshold <threshold:number>] [--raw <json>]")
	.description("Get comprehension score history for tracked files. Shows per-file scores, trends, and files below a configurable threshold.")
	.usage("[--directory <directory>] [--threshold <threshold:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--directory <directory>", "Project directory to check (default: current directory)")
	.option("--threshold <threshold:number>", "Score threshold for 'at risk' files (default: 6) (default: 6; example: 6)", (value) => parseFloat(value))
	
	.alias("understand_score")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.directory !== undefined) args.directory = cmdOpts.directory;
		if (cmdOpts.threshold !== undefined) args.threshold = cmdOpts.threshold;
			const call = (proxy.understandScore as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call understand.understand_score(threshold: 6)");

program
	.command('__mcporter_inspect', { hidden: true })
	.description('Internal metadata printer for mcporter inspect-cli.')
	.action(() => {
		const payload = buildMetadataPayload();
		console.log(JSON.stringify(payload, null, 2));
	});

configureToolCommandHelps();

const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === '0' || FORCE_COLOR === 'false';
const forceEnableColor = FORCE_COLOR === '1' || FORCE_COLOR === 'true' || FORCE_COLOR === '2' || FORCE_COLOR === '3';
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout as NodeJS.WriteStream | undefined;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || (!forceDisableColor && Boolean(stdoutStream?.isTTY)));

const tint = {
	bold(text: string): string {
		return supportsAnsiColor ? '[1m' + text + '[0m' : text;
	},
	dim(text: string): string {
		return supportsAnsiColor ? '[90m' + text + '[0m' : text;
	},
	extraDim(text: string): string {
		return supportsAnsiColor ? '[38;5;244m' + text + '[0m' : text;
	},
};

function configureGeneratedCommandHelp(command: Command): void {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + ' ' + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? '';
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? '';
			return supportsAnsiColor ? tint.extraDim(description) : description;
		},
	});
}

function configureToolCommandHelps(): void {
	program.commands.forEach((cmd) => {
		if (cmd.name() === '__mcporter_inspect') {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}

function renderStandaloneHelp(): string {
	const colorfulTitle = tint.bold(embeddedName) + ' ' + tint.dim('â€” ' + embeddedDescription);
	const plainTitle = embeddedName + ' â€” ' + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [title, '', 'Usage: ' + embeddedName + ' <command> [options]', ''];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push('', formatGlobalFlags(), '', formatQuickStart());
	if (generatorInfo) {
		lines.push('', tint.extraDim(generatorInfo));
	}
	return lines.join('\n');
}

program.helpInformation = () => renderStandaloneHelp();

function formatEmbeddedTools(): string {
	const header = supportsAnsiColor ? tint.bold('Embedded tools') : 'Embedded tools';
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description
			? supportsAnsiColor
				? tint.extraDim(entry.description)
				: entry.description
			: undefined;
		const base = renderedDesc ? entry.name + ' - ' + renderedDesc : entry.name;
		lines.push('  ' + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push('    ' + renderedFlags);
		}
		lines.push('');
	});
	if (lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines.join('\n');
}

function formatGlobalFlags(): string {
	const header = supportsAnsiColor ? tint.bold('Global flags') : 'Global flags';
	const entries = [
		['-t, --timeout <ms>', 'Call timeout in milliseconds'],
		['-o, --output <format>', 'text | markdown | json | raw (default text)'],
	];
	const formatted = entries.map(([flag, summary]) => '  ' + flag.padEnd(28) + summary);
	return [header, ...formatted].join('\n');
}

function formatQuickStart(): string {
  const header = supportsAnsiColor ? tint.bold('Quick start') : 'Quick start';
  const examples = quickStartExamples();
  if (!examples.length) {
    return header;
  }
  const formatted = examples.map(([cmd, note]) => '  ' + cmd + '\n    ' + tint.dim('# ' + note));
  return [header, ...formatted].join('\n');
}

function quickStartExamples(): Array<[string, string]> {
  const examples: Array<[string, string]> = [];
  const commandMap = new Map<string, string>();
  program.commands.forEach((cmd) => {
    const name = cmd.name();
    if (name !== '__mcporter_inspect') {
      commandMap.set(name, name);
    }
  });
  const embedded = Array.isArray(generatorTools) ? generatorTools : [];
  for (const entry of embedded.slice(0, 3)) {
    const commandName = commandMap.get(entry.name) ?? entry.name;
    const flags = entry.flags ? ' ' + entry.flags.replace(/<[^>]+>/g, '<value>') : '';
    examples.push([embeddedName + ' ' + commandName + flags, 'invoke ' + commandName]);
  }
  if (!examples.length) {
    examples.push([embeddedName + ' <tool> --key value', 'invoke a tool with flags']);
  }
  return examples;
}

function printResult(result: unknown, format: string) {
	const wrapped = createCallResult(result);
	switch (format) {
		case 'json': {
			const json = wrapped.json();
			if (json) {
				console.log(JSON.stringify(json, null, 2));
				return;
			}
			break;
		}
		case 'markdown': {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case 'raw': {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
	const base = { ...server } as Record<string, unknown>;
	if ((server.command as any).kind === 'http') {
		const urlRaw = (server.command as any).url;
		const urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				url: new URL(urlValue),
			},
		};
	}
	if ((server.command as any).kind === 'stdio') {
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				args: [ ...((server.command as any).args ?? []) ],
			},
		};
	}
	return base;
}

function determineArtifactKind(): 'template' | 'bundle' | 'binary' {
	const scriptPath = typeof process !== 'undefined' && Array.isArray(process.argv) ? process.argv[1] ?? '' : '';
	if (scriptPath.endsWith('.ts')) {
		return 'template';
	}
	if (scriptPath.endsWith('.js')) {
		return 'bundle';
	}
	return 'binary';
}

function resolveArtifactPath(): string {
	if (typeof process !== 'undefined' && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}

function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path = resolveArtifactPath();
	if (artifactKind === 'template' && path) {
		invocation.outputPath = invocation.outputPath ?? path;
	} else if (artifactKind === 'bundle' && path) {
		invocation.bundle = invocation.bundle ?? path;
	} else if (artifactKind === 'binary' && path) {
		invocation.compile = invocation.compile ?? path;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path,
			kind: artifactKind,
		},
		invocation,
	};
}

async function ensureRuntime(): Promise<Awaited<ReturnType<typeof createRuntime>>> {
	return await createRuntime({
		servers: [normalizeEmbeddedServer(embeddedServer)],
	});
}

async function invokeWithTimeout<T>(call: Promise<T>, timeout: number): Promise<T> {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer: ReturnType<typeof setTimeout> | undefined;
	try {
		return await Promise.race([
			call,
			new Promise<never>((_, reject) => {
				timer = setTimeout(() => {
					reject(new Error('Call timed out after ' + timeout + 'ms.'));
				}, timeout);
			}),
		]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}

async function runCli(): Promise<void> {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}

if (process.env.MCPORTER_DISABLE_AUTORUN !== '1') {
	runCli().catch((error) => {
		const message = error instanceof Error ? error.message : String(error);
		console.error(message);
		process.exit(1);
	});
}
